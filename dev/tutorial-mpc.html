<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Predictive Control · Tutorials</title><meta name="title" content="Model Predictive Control · Tutorials"/><meta property="og:title" content="Model Predictive Control · Tutorials"/><meta property="twitter:title" content="Model Predictive Control · Tutorials"/><meta name="description" content="Documentation for Tutorials."/><meta property="og:description" content="Documentation for Tutorials."/><meta property="twitter:description" content="Documentation for Tutorials."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Tutorials</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Getting Started</a></li><li><span class="tocitem">Tutorials and Advanced Features</span><ul><li><a class="tocitem" href="tutorial-continuation.html">Discrete continuation</a></li><li><a class="tocitem" href="tutorial-discretisation.html">Discretisation methods</a></li><li><a class="tocitem" href="tutorial-nlp.html">NLP manipulations</a></li><li><a class="tocitem" href="tutorial-iss.html">Indirect simple shooting</a></li><li><a class="tocitem" href="tutorial-goddard.html">Goddard: direct, indirect</a></li><li><a class="tocitem" href="tutorial-lqr.html">Linear–quadratic regulator</a></li><li><a class="tocitem" href="tutorial-mam.html">Minimal action</a></li><li class="is-active"><a class="tocitem" href="tutorial-mpc.html">Model Predictive Control</a><ul class="internal"><li><a class="tocitem" href="#Data"><span>Data</span></a></li><li><a class="tocitem" href="#OptimalControl-solver"><span>OptimalControl solver</span></a></li><li><a class="tocitem" href="#First-resolution"><span>First resolution</span></a></li><li><a class="tocitem" href="#Simulation-of-the-Real-System"><span>Simulation of the Real System</span></a></li><li><a class="tocitem" href="#MPC-Approach"><span>MPC Approach</span></a></li><li><a class="tocitem" href="#Display"><span>Display</span></a></li><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials and Advanced Features</a></li><li class="is-active"><a href="tutorial-mpc.html">Model Predictive Control</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial-mpc.html">Model Predictive Control</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/Tutorials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/Tutorials.jl/blob/main/docs/src/tutorial-mpc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Navigation-problem,-MPC-approach"><a class="docs-heading-anchor" href="#Navigation-problem,-MPC-approach">Navigation problem, MPC approach</a><a id="Navigation-problem,-MPC-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Navigation-problem,-MPC-approach" title="Permalink"></a></h1><p>We consider a ship in a constant current <span>$w=(w_x,w_y)$</span>, where <span>$\|w\|&lt;1$</span>.  The <a href="https://en.wikipedia.org/wiki/Heading">heading angle</a> is controlled, leading to the following differential equations:</p><p class="math-container">\[\begin{array}{rcl}
    \dot{x}(t) &amp;=&amp; w_x + \cos\theta(t), \quad t \in [0, t_f] \\
    \dot{y}(t) &amp;=&amp; w_y + \sin\theta(t), \\
    \dot{\theta}(t) &amp;=&amp; u(t). 
\end{array}\]</p><p>The angular velocity is limited and normalized: <span>$\|u(t)\| \leq 1$</span>. There are boundary conditions at the initial time <span>$t=0$</span> and at the final time <span>$t=t_f$</span>, on the position <span>$(x,y)$</span> and on the angle <span>$\theta$</span>. The objective is to minimize the final time. This topic stems from a collaboration between the University Côte d&#39;Azur and the French company <a href="https://www.cgg.com">CGG</a>, which is interested in optimal maneuvers of very large ships for marine exploration.</p><img 
      src="./assets/ship.jpg"
      style="display: block;
      margin-left: auto;
      margin-right: auto;
      width: 50%;"
><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><pre><code class="language-julia hljs">using LinearAlgebra
using NLPModelsIpopt
using OptimalControl
using OrdinaryDiffEq
using Plots
using Plots.PlotMeasures
using Printf

t0 = 0.
x0 = 0.
y0 = 0.
θ0 = π/7
xf = 4.
yf = 7.
θf = -π/2

function current(x, y) # current as a function of position
    ε = 1e-1
    w = [ 0.6, 0.4 ]
    δw = ε * [ y, -x ] / sqrt(1+x^2+y^2)
    w = w + δw
    if (w[1]^2 + w[2]^2 &gt;= 1)
        error(&quot;|w| &gt;= 1&quot;)
    end
    return w
end

#
function plot_state!(plt, x, y, θ; color=1)
    plot!(plt, [x], [y], marker=:circle, legend=false, color=color, markerstrokecolor=color, markersize=5, z_order=:front)
    quiver!(plt, [x], [y], quiver=([cos(θ)], [sin(θ)]), color=color, linewidth=2, z_order=:front)
    return plt
end

function plot_current!(plt; current=current, N=10, scaling=1)
    for x ∈ range(xlims(plt)..., N)
        for y ∈ range(ylims(plt)..., N)
            w = scaling*current(x, y)
            quiver!(plt, [x], [y], quiver=([w[1]], [w[2]]), color=:black, linewidth=0.5, z_order=:back)
        end
    end
    return plt
end

# Display the boundary conditions and the current in the augmented phase plane
plt = plot(
    xlims=(-2, 6),
    ylims=(-1, 8),
    size=(600, 600),
    aspect_ratio=1,
    xlabel=&quot;x&quot;,
    ylabel=&quot;y&quot;,
    title=&quot;Boundary Conditions&quot;,
    leftmargin=5mm,
    bottommargin=5mm,
)

plot_state!(plt, x0, y0, θ0; color=2)
plot_state!(plt, xf, yf, θf; color=2)
annotate!([(x0, y0, (&quot;q₀&quot;, 12, :top)), (xf, yf, (&quot;qf&quot;, 12, :bottom))])
plot_current!(plt)</code></pre><img src="tutorial-mpc-baf1f349.svg" alt="Example block output"/><pre><code class="language-julia hljs">function plot_trajectory!(plt, t, x, y, θ; N=5) # N: number of points where we will display θ

    # trajectory
    plot!(plt, x.(t), y.(t), legend=false, color=1, linewidth=2, z_order=:front)

    if N &gt; 0

        # length of the path
        s = 0
        for i ∈ 2:length(t)
            s += norm([x(t[i]), y(t[i])] - [x(t[i-1]), y(t[i-1])])
        end

        # interval of length
        Δs = s/(N+1)
        tis = []
        s = 0
        for i ∈ 2:length(t)
            s += norm([x(t[i]), y(t[i])] - [x(t[i-1]), y(t[i-1])])
            if s &gt; Δs &amp;&amp; length(tis) &lt; N
                push!(tis, t[i])
                s = 0
            end
        end

        # display intermediate points
        for ti ∈ tis
            plot_state!(plt, x(ti), y(ti), θ(ti); color=1)
        end

    end

    return plt

end</code></pre><h2 id="OptimalControl-solver"><a class="docs-heading-anchor" href="#OptimalControl-solver">OptimalControl solver</a><a id="OptimalControl-solver-1"></a><a class="docs-heading-anchor-permalink" href="#OptimalControl-solver" title="Permalink"></a></h2><pre><code class="language-julia hljs">function solve(t0, x0, y0, θ0, xf, yf, θf, w;
    grid_size=300, tol=1e-8, max_iter=500, print_level=4, display=true, disc_method=:euler)

    # Definition of the problem
    ocp = @def begin

        tf ∈ R, variable
        t ∈ [t0, tf], time
        q = (x, y, θ) ∈ R³, state
        u ∈ R, control

        -1 ≤ u(t) ≤ 1

        -2 ≤ x(t) ≤ 6
        -2 ≤ y(t) ≤ 8
        -2π ≤ x(t) ≤ 2π

        q(t0) == [x0, y0, θ0]
        q(tf) == [xf, yf, θf]

        q̇(t) == [w[1]+cos(θ(t)),
                  w[2]+sin(θ(t)),
                  u(t)]

        tf → min

    end

    # Initialization
    tf_init = 1.5*norm([xf, yf]-[x0, y0])
    x_init(t) = [ x0, y0, θ0 ] * (tf_init-t)/(tf_init-t0) + [xf, yf, θf] * (t-t0)/(tf_init-t0)
    u_init = (θf - θ0) / (tf_init-t0)
    init = (state=x_init, control=u_init, variable=tf_init)

    # Resolution
    sol = OptimalControl.solve(ocp;
        init=init,
        grid_size=grid_size,
        tol=tol,
        max_iter=max_iter,
        print_level=print_level,
        display=display,
        disc_method=disc_method,
    )

    # Retrieval of useful data
    t = time_grid(sol)
    q = state(sol)
    x = t -&gt; q(t)[1]
    y = t -&gt; q(t)[2]
    θ = t -&gt; q(t)[3]
    u = control(sol)
    tf = variable(sol)

    return t, x, y, θ, u, tf, iterations(sol), sol.solver_infos.constraints_violation

end</code></pre><h2 id="First-resolution"><a class="docs-heading-anchor" href="#First-resolution">First resolution</a><a id="First-resolution-1"></a><a class="docs-heading-anchor-permalink" href="#First-resolution" title="Permalink"></a></h2><p>We consider a constant current and we solve a first time the problem.</p><pre><code class="language-julia hljs"># Resolution
t, x, y, θ, u, tf, iter, cons = solve(t0, x0, y0, θ0, xf, yf, θf, current(x0, y0); display=false);

println(&quot;Iterations: &quot;, iter)
println(&quot;Constraints violation: &quot;, cons)
println(&quot;tf: &quot;, tf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iterations: 56
Constraints violation: 5.06292563429156e-10
tf: 9.96925102618608</code></pre><pre><code class="language-julia hljs"># Displaying the trajectory
plt_q = plot(xlims=(-2, 6), ylims=(-1, 8), aspect_ratio=1, xlabel=&quot;x&quot;, ylabel=&quot;y&quot;)
plot_state!(plt_q, x0, y0, θ0; color=2)
plot_state!(plt_q, xf, yf, θf; color=2)
plot_current!(plt_q; current=(x, y) -&gt; current(x0, y0))
plot_trajectory!(plt_q, t, x, y, θ)

# Displaying the control
plt_u = plot(t, u; color=1, legend=false, linewidth=2, xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

# Final display
plot(plt_q, plt_u;
    layout=(1, 2),
    size=(1200, 600),
    leftmargin=5mm,
    bottommargin=5mm,
    plot_title=&quot;Constant Current Simulation&quot;
)</code></pre><img src="tutorial-mpc-49c30765.svg" alt="Example block output"/><h2 id="Simulation-of-the-Real-System"><a class="docs-heading-anchor" href="#Simulation-of-the-Real-System">Simulation of the Real System</a><a id="Simulation-of-the-Real-System-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-of-the-Real-System" title="Permalink"></a></h2><p>In the previous simulation, we assumed that the current is constant. However, from a practical standpoint, the current depends on the position <span>$(x, y)$</span>. Given a current model, provided by the function <code>current</code>, we can simulate the actual trajectory of the ship, as long as we have the initial condition and the control over time.</p><pre><code class="language-julia hljs">function realistic_trajectory(tf, t0, x0, y0, θ0, u, current; abstol=1e-12, reltol=1e-12, saveat=[])

    function rhs!(dq, q, dummy, t)
        x, y, θ = q
        w = current(x, y)
        dq[1] = w[1] + cos(θ)
        dq[2] = w[2] + sin(θ)
        dq[3] = u(t)
    end

    q0 = [x0, y0, θ0]
    tspan = (t0, tf)
    ode = ODEProblem(rhs!, q0, tspan)
    sol = OrdinaryDiffEq.solve(ode, Tsit5(), abstol=abstol, reltol=reltol, saveat=saveat)

    t = sol.t
    x = t -&gt; sol(t)[1]
    y = t -&gt; sol(t)[2]
    θ = t -&gt; sol(t)[3]

    return t, x, y, θ

end</code></pre><pre><code class="language-julia hljs"># Realistic trajectory
t, x, y, θ = realistic_trajectory(tf, t0, x0, y0, θ0, u, current)

# Displaying the trajectory
plt_q = plot(xlims=(-2, 6), ylims=(-1, 8), aspect_ratio=1, xlabel=&quot;x&quot;, ylabel=&quot;y&quot;)
plot_state!(plt_q, x0, y0, θ0; color=2)
plot_state!(plt_q, xf, yf, θf; color=2)
plot_current!(plt_q; current=current)
plot_trajectory!(plt_q, t, x, y, θ)
plot_state!(plt_q, x(tf), y(tf), θ(tf); color=3)

# Displaying the control
plt_u = plot(t, u; color=1, legend=false, linewidth=2, xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

# Final display
plot(plt_q, plt_u;
    layout=(1, 2),
    size=(1200, 600),
    leftmargin=5mm,
    bottommargin=5mm,
    plot_title=&quot;Simulation with Current Model&quot;
)</code></pre><img src="tutorial-mpc-8f816f8b.svg" alt="Example block output"/><h2 id="MPC-Approach"><a class="docs-heading-anchor" href="#MPC-Approach">MPC Approach</a><a id="MPC-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#MPC-Approach" title="Permalink"></a></h2><p>In practice, we do not have the actual current data for the entire trajectory in advance, which is why we will regularly recalculate the optimal control. The idea is to update the optimal control at regular time intervals, taking into account the current at the position where the ship is located. We are therefore led to solve a number of problems with constant current, with this being updated regularly. This is an introduction to the so-called Model Predictive Control (MPC) methods.</p><pre><code class="language-julia hljs">function MPC(t0, x0, y0, θ0, xf, yf, θf, current)

    Nmax = 20   # maximum number of iterations for the MPC method
    ε = 1e-1    # radius on the final condition to stop calculations
    Δt = 1.0    # fixed time step for the MPC method
    P = 300      # number of discretization points for the solver

    t1 = t0
    x1 = x0
    y1 = y0
    θ1 = θ0

    data = []

    N = 1
    stop = false

    while !stop

        # Retrieve the current at the current position
        w = current(x1, y1)

        # Solve the problem
        t, x, y, θ, u, tf, iter, cons = solve(t1, x1, y1, θ1, xf, yf, θf, w; grid_size=P, display=false);

        # Calculate the next time
        if (t1 + Δt &lt; tf)
            t2 = t1 + Δt
        else
            t2 = tf
            stop = true
        end

        # Store the data: the current initial time, the next time, the control
        push!(data, (t2, t1, x(t1), y(t1), θ(t1), u, tf))

        # Update the parameters of the MPC method: simulate reality
        t, x, y, θ = realistic_trajectory(t2, t1, x1, y1, θ1, u, current)
        t1 = t2
        x1 = x(t1)
        y1 = y(t1)
        θ1 = θ(t1)

        # Calculate the distance to the target position
        distance = norm([x1, y1, θ1] - [xf, yf, θf])
        if N == 1
            println(&quot;     N    Distance  Iterations   Constraints       tf&quot;)
            println(&quot;------------------------------------------------------&quot;)
        end
        @printf(&quot;%6d&quot;, N)
        @printf(&quot;%12.4f&quot;, distance)
        @printf(&quot;%12d&quot;, iter)
        @printf(&quot;%14.4e&quot;, cons)
        @printf(&quot;%10.4f\n&quot;, tf)
        if !((distance &gt; ε) &amp;&amp; (N &lt; Nmax))
            stop = true
        end

        #
        N += 1

    end

    return data
end

data = MPC(t0, x0, y0, θ0, xf, yf, θf, current)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">     N    Distance  Iterations   Constraints       tf
------------------------------------------------------
     1      7.1694          56    5.0629e-10    9.9693
     2      6.6190         108    3.7585e-10   11.5842
     3      6.8118          20    5.2798e-11   12.1924
     4      6.8057          76    4.8150e-10   12.4936
     5      6.8369          33    1.1092e-09   12.6760
     6      6.9041          32    4.3996e-10   12.8107
     7      7.0071          98    1.1482e-10   12.9111
     8      7.1405          32    9.6242e-12   12.9903
     9      6.6825          41    1.8091e-10   13.3845
    10      5.5860          43    1.5091e-02   13.3741
    11      3.9737         109    1.2698e-02   13.3546
    12      2.1132          32    6.5942e-11   13.3118
    13      0.4197         117    2.3191e-05   13.2949
    14      0.0313         100    1.0318e-04   13.3051</code></pre><h2 id="Display"><a class="docs-heading-anchor" href="#Display">Display</a><a id="Display-1"></a><a class="docs-heading-anchor-permalink" href="#Display" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Trajectory
plt_q = plot(xlims=(-2, 6), ylims=(-1, 8), aspect_ratio=1, xlabel=&quot;x&quot;, ylabel=&quot;y&quot;)

# Final condition
plot_state!(plt_q, xf, yf, θf; color=2)

# Current
plot_current!(plt_q; current=current)

# Control
plt_u = plot(xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

for d ∈ data

    t2, t1, x1, y1, θ1, u, tf = d

    # Calculate the actual trajectory
    t, x, y, θ = realistic_trajectory(t2, t1, x1, y1, θ1, u, current)

    # Trajectory
    plot_state!(plt_q, x1, y1, θ1; color=2)
    plot_trajectory!(plt_q, t, x, y, θ; N=0)

    # Control
    plot!(plt_u, t, u; color=1, legend=false, linewidth=2)

end

# last point
d = data[end]
t2, t1, x1, y1, θ1, u, tf = d
t, x, y, θ = realistic_trajectory(t2, t1, x1, y1, θ1, u, current)
plot_state!(plt_q, x(tf), y(tf), θ(tf); color=3)

#
plot(plt_q, plt_u;
    layout=(1, 2),
    size=(1200, 600),
    leftmargin=5mm,
    bottommargin=5mm,
    plot_title=&quot;Simulation with Current Model&quot;
)</code></pre><img src="tutorial-mpc-d2b4c46f.svg" alt="Example block output"/><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><p>If you use a discretization method other than <code>:euler</code>, the solver may converge to a local solution that is not globally optimal.</p><pre><code class="language-julia hljs"># Resolution
t, x, y, θ, u, tf, iter, cons = solve(t0, x0, y0, θ0, xf, yf, θf, current(x0, y0);
    display=false, disc_method=:gauss_legendre_3);

println(&quot;Iterations: &quot;, iter)
println(&quot;Constraints violation: &quot;, cons)
println(&quot;tf: &quot;, tf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iterations: 54
Constraints violation: 2.5278656945459943e-10
tf: 13.136220808306978</code></pre><pre><code class="language-julia hljs"># Displaying the trajectory
plt_q = plot(xlims=(-2, 6), ylims=(-1, 8), aspect_ratio=1, xlabel=&quot;x&quot;, ylabel=&quot;y&quot;)
plot_state!(plt_q, x0, y0, θ0; color=2)
plot_state!(plt_q, xf, yf, θf; color=2)
plot_current!(plt_q; current=(x, y) -&gt; current(x0, y0))
plot_trajectory!(plt_q, t, x, y, θ)

# Displaying the control
plt_u = plot(t, u; color=1, legend=false, linewidth=2, xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

# Final display
plot(plt_q, plt_u;
    layout=(1, 2),
    size=(1200, 600),
    leftmargin=5mm,
    bottommargin=5mm,
    plot_title=&quot;Constant Current Simulation&quot;
)</code></pre><img src="tutorial-mpc-ff835d79.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial-mam.html">« Minimal action</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 13 July 2025 11:33">Sunday 13 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
